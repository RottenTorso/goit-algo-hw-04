# Порівняльний аналіз алгоритмів сортування

## Вступ

У цьому проекті проведено порівняльний аналіз трьох алгоритмів сортування: злиттям, вставками та Timsort. Метою є емпіричне підтвердження теоретичних оцінок складності алгоритмів та демонстрація ефективності Timsort.

## Алгоритми

1. **Сортування злиттям (Merge Sort)**: O(n log n)
2. **Сортування вставками (Insertion Sort)**: O(n^2)
3. **Timsort**: O(n log n) у середньому випадку

## Набори даних

- Випадкові масиви
- Відсортовані масиви
- Зворотно відсортовані масиви

## Результати

| Тип даних | Розмір | Merge Sort (сек) | Insertion Sort (сек) | Timsort (сек) |
|-----------|--------|-------------------|----------------------|---------------|
| Випадкові | 100    | 0.000455          | 0.000341             | 0.000021      |
| Випадкові | 1000   | 0.007336          | 0.036875             | 0.000123      |
| Випадкові | 10000  | 0.037603          | 3.993328             | 0.001726      |
| Відсортовані | 100    | 0.000143          | 0.000013             | 0.000004      |
| Відсортовані | 1000   | 0.001836          | 0.000143             | 0.000014      |
| Відсортовані | 10000  | 0.029697          | 0.001379             | 0.000135      |
| Зворотно відсортовані | 100    | 0.000141          | 0.000414             | 0.000003      |
| Зворотно відсортовані | 1000   | 0.001801          | 0.063337             | 0.000019      |
| Зворотно відсортовані | 10000  | 0.035179          | 7.958385             | 0.000159      |

## Висновки

- Timsort є найефективнішим алгоритмом для більшості випадків.
- Сортування злиттям також показує хороші результати, але поступається Timsort.
- Сортування вставками значно повільніше на великих масивах.
- Використання вбудованих функцій сортування Python є оптимальним вибором для досягнення найкращої продуктивності.